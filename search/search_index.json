{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mlflow-fastapi-docker","text":"<p>This is a template repository for Python projects that use uv for their dependency management.</p>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#mlflow_fastapi_docker.train_deploy.AnomalyDetails","title":"<code>AnomalyDetails</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Detailed information about detected anomaly</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>class AnomalyDetails(BaseModel):\n    \"\"\"Detailed information about detected anomaly\"\"\"\n\n    severity: str\n    action: str\n    explanation: str\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.PredictRequest","title":"<code>PredictRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model with all 53 original columns</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>class PredictRequest(BaseModel):\n    \"\"\"Request model with all 53 original columns\"\"\"\n\n    device_id: int\n\n    # CR1 Motor X measurements\n    cr1_mtx_temperature: float\n    cr1_mtx_current: float\n    cr1_mtx_power: float\n    cr1_mtx_speed: float\n    cr1_mtx_torque: float\n    cr1_mtx_position: float\n\n    # CR1 Motor Y measurements\n    cr1_mty_temperature: float\n    cr1_mty_current: float\n    cr1_mty_power: float\n    cr1_mty_speed: float\n    cr1_mty_torque: float\n    cr1_mty_position: float\n\n    # CR1 Motor Z measurements\n    cr1_mtz_temperature: float\n    cr1_mtz_current: float\n    cr1_mtz_power: float\n    cr1_mtz_speed: float\n    cr1_mtz_torque: float\n    cr1_mtz_position: float\n\n    # CR1 Belt and Load measurements\n    cr1_y_beltvibration_xangle: float\n    cr1_y_beltvibration_yangle: float\n    cr1_y_load: float\n\n    # CR2 Motor X measurements\n    cr2_mtx_temperature: float\n    cr2_mtx_current: float\n    cr2_mtx_power: float\n    cr2_mtx_speed: float\n    cr2_mtx_torque: float\n    cr2_mtx_position: float\n\n    # CR2 Motor Y measurements\n    cr2_mty_temperature: float\n    cr2_mty_current: float\n    cr2_mty_power: float\n    cr2_mty_speed: float\n    cr2_mty_torque: float\n    cr2_mty_position: float\n\n    # CR2 Motor Z measurements\n    cr2_mtz_temperature: float\n    cr2_mtz_current: float\n    cr2_mtz_power: float\n    cr2_mtz_speed: float\n    cr2_mtz_torque: float\n    cr2_mtz_position: float\n\n    # CR2 Belt and Load measurements\n    cr2_y_beltvibration_xangle: float\n    cr2_y_beltvibration_yangle: float\n    cr2_y_load: float\n\n    # Mode and Status columns\n    cr1_mode: int\n    cr2_mode: int\n    cr1_has_request: int\n    cr2_has_request: int\n    cr1_has_carrier: int\n    cr2_has_carrier: int\n    cr1_to_exit_full: int\n    cr2_to_exit_full: int\n\n    # time\n    date: int\n    new_stamp: int\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.PredictResponse","title":"<code>PredictResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for multi-class anomaly detection</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>class PredictResponse(BaseModel):\n    \"\"\"Response model for multi-class anomaly detection\"\"\"\n\n    prediction_label: str  # Human-readable label\n    anomaly_details: Optional[AnomalyDetails] = None  # Detailed info if anomaly detected\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.add_noise","title":"<code>add_noise(df, noise_pct, noise_std, noise_type, feature_cols)</code>","text":"<p>Add synthetic noise to data to create anomalies.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Input DataFrame</p> required <code>noise_pct</code> <code>float</code> <p>Percentage of rows to add noise to</p> required <code>noise_std</code> <code>float</code> <p>Standard deviation of the noise distribution</p> required <code>noise_type</code> <code>str</code> <p>Type of noise to add (gaussian, laplace, poisson, etc.)</p> required <code>feature_cols</code> <code>list[str]</code> <p>Feature columns to be added noise</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A new DataFrame where <code>noise_pct * len(df)</code> randomly chosen rows have had their feature values perturbed according to <code>noise_type</code> &amp; <code>noise_std</code>. For those rows 'Anomaly_Label' is set to 1.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def add_noise(\n    df: pd.DataFrame, noise_pct: float, noise_std: float, noise_type: str, feature_cols: list[str]\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Add synthetic noise to data to create anomalies.\n\n    Args:\n        df: Input DataFrame\n        noise_pct: Percentage of rows to add noise to\n        noise_std: Standard deviation of the noise distribution\n        noise_type: Type of noise to add (gaussian, laplace, poisson, etc.)\n        feature_cols: Feature columns to be added noise\n\n    Returns:\n        A new DataFrame where `noise_pct * len(df)` randomly chosen rows have had their feature values perturbed according to `noise_type` &amp; `noise_std`. For those rows 'Anomaly_Label' is set to 1.\n    \"\"\"\n    # add seed for reproducibility\n    rng = np.random.RandomState(0)\n    num_rows = len(df)\n    num_noise = int(num_rows * noise_pct)\n    noise_idx = rng.choice(df.index, size=num_noise, replace=False)\n\n    # -- classical noise types --\n    # gaussian, laplace, poisson, gamma, bernoulli\n    noise_mean = 0\n\n    exclude_cols = [\n        \"cr1_mode\",\n        \"cr2_mode\",\n        \"cr1_has_request\",\n        \"cr2_has_request\",\n        \"cr1_has_carrier\",\n        \"cr2_has_carrier\",\n        \"cr1_to_exit_full\",\n        \"cr2_to_exit_full\",\n    ]\n\n    noise_columns = _get_noise_columns(feature_cols, exclude_cols)\n\n    if noise_type == \"gaussian\":\n        noise = rng.normal(noise_mean, noise_std, size=(num_noise, len(noise_columns)))\n    elif noise_type == \"laplace\":\n        noise = rng.laplace(noise_mean, noise_std, size=(num_noise, len(noise_columns)))\n    elif noise_type == \"poisson\":\n        noise = rng.poisson(noise_std, size=(num_noise, len(noise_columns))) - noise_std\n    elif noise_type == \"gamma\":\n        shape = 1\n        scale = noise_std / np.sqrt(shape)\n        noise = rng.gamma(shape, scale, size=(num_noise, len(noise_columns)))\n        # Center the gamma noise\n        noise = noise - noise.mean()\n        if noise.std() != 0:\n            noise *= noise_std / noise.std()\n    elif noise_type == \"bernoulli\":\n        # Flip sign of ~50% of the features in those rows\n        mask = rng.binomial(1, 0.5, size=(num_noise, len(noise_columns))).astype(bool)\n        for idx, row_mask in zip(noise_idx, mask):\n            for j, col in enumerate(noise_columns):\n                if row_mask[j]:\n                    df.loc[idx, col] = -df.loc[idx, col]\n        df.loc[noise_idx, \"Anomaly_Label\"] = 1\n        return df\n    else:\n        raise UnsupportedNoiseTypeError(noise_type)\n\n    # Add the continuous noise for the non-bernoulli types:\n    df.loc[noise_idx, noise_columns] += noise\n    df.loc[noise_idx, \"Anomaly_Label\"] = 1\n    return df\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.check_abnormal_motor_torque","title":"<code>check_abnormal_motor_torque(row, prefix='cr2_')</code>","text":"<p>Abnormal Motor Torque: If the torque in any axis deviates beyond its allowed range flag an Abnormal Motor Torque anomaly.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def check_abnormal_motor_torque(row: dict[str, Any], prefix: str = \"cr2_\") -&gt; Optional[str]:\n    \"\"\"\n    Abnormal Motor Torque:\n    If the torque in any axis deviates beyond its allowed range flag an Abnormal Motor Torque anomaly.\n    \"\"\"\n    for axis in [\"x\", \"y\", \"z\"]:\n        torque = row[f\"{prefix}mt{axis}_torque\"]\n        t_min, t_max = TORQUE_LIMITS[axis]\n        if torque &lt; t_min or torque &gt; t_max:\n            return f\"Abnormal Motor Torque ({prefix}mtx/mty/mtz)\"\n    return None\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.check_abnormal_power_variation","title":"<code>check_abnormal_power_variation(row, prefix='cr2_')</code>","text":"<p>Abnormal Power Variation: If the power reading in any axis is outside its normal range flag a Abnormal Power Variation anomaly.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def check_abnormal_power_variation(row: dict[str, Any], prefix: str = \"cr2_\") -&gt; Optional[str]:\n    \"\"\"\n    Abnormal Power Variation:\n    If the power reading in any axis is outside its normal range flag a Abnormal Power Variation anomaly.\n    \"\"\"\n    for axis in [\"x\", \"y\", \"z\"]:\n        power = row[f\"{prefix}mt{axis}_power\"]\n        p_min, p_max = POWER_LIMITS[axis]\n        if power &lt; p_min or power &gt; p_max:\n            return f\"Abnormal Power Variation ({prefix}mtx/mty/mtz)\"\n    return None\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.check_anomalous_motor_position","title":"<code>check_anomalous_motor_position(row, prefix='cr2_')</code>","text":"<p>Anomalous Motor Position: If the motor position is out of its allowed range, flag the anomaly \"anomalous motor position\".</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def check_anomalous_motor_position(row: dict[str, Any], prefix: str = \"cr2_\") -&gt; Optional[str]:\n    \"\"\"\n    Anomalous Motor Position:\n    If the motor position is out of its allowed range, flag the anomaly \"anomalous motor position\".\n    \"\"\"\n    for axis in [\"x\", \"y\", \"z\"]:\n        pos = row[f\"{prefix}mt{axis}_position\"]\n        pos_min, pos_max = POSITION_LIMITS[axis]\n\n        if pos &lt; pos_min or pos &gt; pos_max:\n            return f\"Anomalous Motor Position ({prefix}mtx/mty/mtz)\"\n    return None\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.check_high_speed_operation","title":"<code>check_high_speed_operation(row, prefix='cr2_')</code>","text":"<p>High Speed Operation: If the speed in any axis is outside the allowed range while the current remains within its normal range, flag an High Speed Operation anomaly.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def check_high_speed_operation(row: dict[str, Any], prefix: str = \"cr2_\") -&gt; Optional[str]:\n    \"\"\"\n    High Speed Operation:\n    If the speed in any axis is outside the allowed range while the current remains within its normal range,\n    flag an High Speed Operation anomaly.\n    \"\"\"\n    for axis in [\"x\", \"y\", \"z\"]:\n        speed = row[f\"{prefix}mt{axis}_speed\"]\n        s_min, s_max = SPEED_LIMITS[axis]\n        if speed &lt; s_min or speed &gt; s_max:\n            return f\"High Speed Operation ({prefix}mtx/mty/mtz)\"\n    return None\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.check_high_vibration","title":"<code>check_high_vibration(row, prefix='cr2_')</code>","text":"<p>High Vibration: If the vibration angles (from belt sensors) are outside their permitted ranges flag a High Vibration anomaly.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def check_high_vibration(row: dict[str, Any], prefix: str = \"cr2_\") -&gt; Optional[str]:\n    \"\"\"\n    High Vibration:\n    If the vibration angles (from belt sensors) are outside their permitted ranges flag a High Vibration anomaly.\n    \"\"\"\n\n    xangle = row[f\"{prefix}y_beltvibration_xangle\"]\n    yangle = row[f\"{prefix}y_beltvibration_yangle\"]\n    excessive_vibration = (\n        xangle &lt; ANGLE_X_LIMITS[0]\n        or xangle &gt; ANGLE_X_LIMITS[1]\n        or yangle &lt; ANGLE_Y_LIMITS[0]\n        or yangle &gt; ANGLE_Y_LIMITS[1]\n    )\n\n    if excessive_vibration:\n        return f\"High Vibration ({prefix}y_beltvibration)\"\n    return None\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.check_motor_overcurrent","title":"<code>check_motor_overcurrent(row, prefix='cr2_')</code>","text":"<p>Motor Overcurrent If the current exceeds its maximum in any axis, flag a Motor Overcurrent anomaly.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def check_motor_overcurrent(row: dict[str, Any], prefix: str = \"cr2_\") -&gt; Optional[str]:\n    \"\"\"\n    Motor Overcurrent\n    If the current exceeds its maximum in any axis, flag a Motor Overcurrent anomaly.\n    \"\"\"\n    for axis in [\"x\", \"y\", \"z\"]:\n        current = row[f\"{prefix}mt{axis}_current\"]\n        _, curr_max = CURRENT_LIMITS[axis]\n        if current &gt; curr_max:\n            return f\"Motor Overcurrent ({prefix}mtx/mty/mtz)\"\n    return None\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.check_motor_overheating","title":"<code>check_motor_overheating(row, prefix='cr2_')</code>","text":"<p>Motor Overheating: If the temperature exceeds its maximum in any axis, flag a Motor Overheating anomaly.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def check_motor_overheating(row: dict[str, Any], prefix: str = \"cr2_\") -&gt; Optional[str]:\n    \"\"\"\n    Motor Overheating:\n    If the temperature exceeds its maximum in any axis, flag a Motor Overheating anomaly.\n    \"\"\"\n    for axis in [\"x\", \"y\", \"z\"]:\n        temp = row[f\"{prefix}mt{axis}_temperature\"]\n        _, temp_max = TEMP_LIMITS[axis]\n        if temp &gt; temp_max:\n            return f\"Motor Overheating ({prefix}mtx/mty/mtz)\"\n    return None\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.decision_layer","title":"<code>decision_layer(anomaly_labels)</code>","text":"Prioritize anomalies based on the following order <ol> <li>Motor Overcurrent (Critical)</li> <li>Motor Overheating (Critical)</li> <li>Anomalous Motor Position (Critical)</li> <li>High Speed Operation (Critical)</li> <li>Abnormal Motor Torque (Critical)</li> <li>High Vibration (High)</li> <li>Abnormal Power Variation (Medium)</li> </ol> <p>Returns a list with a single dictionary containing details for the highest priority anomaly.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def decision_layer(anomaly_labels: list[str]) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Prioritize anomalies based on the following order:\n      1. Motor Overcurrent (Critical)\n      2. Motor Overheating (Critical)\n      3. Anomalous Motor Position (Critical)\n      4. High Speed Operation (Critical)\n      5. Abnormal Motor Torque (Critical)\n      6. High Vibration (High)\n      7. Abnormal Power Variation (Medium)\n\n    Returns a list with a single dictionary containing details for the highest priority anomaly.\n    \"\"\"\n\n    priority_order = [\n        \"Motor Overcurrent\",\n        \"Motor Overheating\",\n        \"Anomalous Motor Position\",\n        \"High Speed Operation\",\n        \"Abnormal Motor Torque\",\n        \"High Vibration\",\n        \"Abnormal Power Variation\",\n    ]\n\n    for anomaly_type in priority_order:\n        matching = [label for label in anomaly_labels if anomaly_type in label]\n        if matching:\n            info = ANOMALY_DETAILS_MAP[anomaly_type]\n            return [\n                {\n                    \"anomaly\": matching[0],\n                    \"severity\": info[\"severity_label\"],\n                    \"action\": info[\"action\"],\n                    \"explanation\": info[\"explanation\"],\n                }\n            ]\n    return []\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.get_anomaly_details_from_data","title":"<code>get_anomaly_details_from_data(row_data)</code>","text":"<p>Apply domain-specific rules to get detailed anomaly information.</p> <p>Parameters:</p> Name Type Description Default <code>row_data</code> <code>dict</code> <p>dictionary containing the sensor data for one sample</p> required <p>Returns:</p> Type Description <code>Optional[AnomalyDetails]</code> <p>AnomalyDetails if anomaly detected, None otherwise</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def get_anomaly_details_from_data(row_data: dict) -&gt; Optional[AnomalyDetails]:\n    \"\"\"\n    Apply domain-specific rules to get detailed anomaly information.\n\n    Args:\n        row_data: dictionary containing the sensor data for one sample\n\n    Returns:\n        AnomalyDetails if anomaly detected, None otherwise\n    \"\"\"\n    # Convert dict to pandas Series for compatibility with existing functions\n    row = pd.Series(row_data)\n\n    # Get anomaly labels using existing domain logic\n    anomaly_labels = get_anomaly_labels(row)\n\n    if not anomaly_labels:\n        return None\n\n    # Use existing decision layer to get prioritized anomaly details\n    decisions = decision_layer(anomaly_labels)\n\n    if decisions:\n        decision = decisions[0]\n        return AnomalyDetails(\n            severity=decision[\"severity\"],\n            action=decision[\"action\"],\n            explanation=decision[\"explanation\"],\n        )\n\n    return None\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.get_anomaly_labels","title":"<code>get_anomaly_labels(row)</code>","text":"<p>Apply domain-specific checks for both Crane 1 (prefix 'cr1_') and Crane 2 (prefix 'cr2_'), and return a list of anomaly labels detected.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def get_anomaly_labels(row: pd.Series) -&gt; list[str]:\n    \"\"\"\n    Apply domain-specific checks for both Crane 1 (prefix 'cr1_') and Crane 2 (prefix 'cr2_'),\n    and return a list of anomaly labels detected.\n    \"\"\"\n    labels = []\n    data = row.to_dict()\n    for prefix in [\"cr1_\", \"cr2_\"]:\n        for check in (\n            check_motor_overcurrent,\n            check_motor_overheating,\n            check_anomalous_motor_position,\n            check_high_speed_operation,\n            check_abnormal_power_variation,\n            check_abnormal_motor_torque,\n            check_high_vibration,\n        ):\n            msg = check(data, prefix=prefix)\n            if msg is not None:\n                labels.append(msg)\n    return labels\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.get_anomaly_mapping","title":"<code>get_anomaly_mapping()</code>","text":"<p>Get cached anomaly mapping or load it</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def get_anomaly_mapping() -&gt; dict[int, str]:\n    \"\"\"Get cached anomaly mapping or load it\"\"\"\n    global _anomaly_mapping_cache\n    if _anomaly_mapping_cache is None:\n        _anomaly_mapping_cache = load_anomaly_type_mapping()\n    return _anomaly_mapping_cache\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.load_and_preprocess_data","title":"<code>load_and_preprocess_data(filenames)</code>","text":"<p>Loads Cubestocker normal data, removes unnecessary features, initializes a new column 'Anomaly_Label' as 0 (normal data) and scales the data.</p> <p>Parameters:</p> Name Type Description Default <code>filenames</code> <code>list[str]</code> <p>Names of the Cubestocker files to be loaded</p> required <p>Returns:</p> Type Description <code>tuple[DataFrame, StandardScaler, list[str]]</code> <p>Preprocessed Dataframe, the scaler, and a list of features used for training.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def load_and_preprocess_data(filenames: list[str]) -&gt; tuple[pd.DataFrame, StandardScaler, list[str]]:\n    \"\"\"\n    Loads Cubestocker normal data, removes unnecessary features, initializes a new column 'Anomaly_Label' as 0 (normal data) and scales the data.\n\n    Args:\n        filenames: Names of the Cubestocker files to be loaded\n\n    Returns:\n        Preprocessed Dataframe, the scaler, and a list of features used for training.\n    \"\"\"\n    dfs = []\n    for fname in filenames:\n        dfi = pd.read_parquet(f\"data/{fname}.parquet\", engine=\"fastparquet\")\n        dfi = dfi.drop(columns=[\"new_stamp\", \"device_id\", \"date\"], errors=\"ignore\")\n        dfi[\"Anomaly_Label\"] = 0\n        dfs.append(dfi)\n\n    df = pd.concat(dfs, ignore_index=True)\n\n    feature_cols = [c for c in df.columns if c != \"Anomaly_Label\"]\n    scaler = StandardScaler()\n    df[feature_cols] = scaler.fit_transform(df[feature_cols])\n    return df, scaler, feature_cols\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.load_anomaly_type_mapping","title":"<code>load_anomaly_type_mapping()</code>","text":"<p>Load the anomaly type mapping from the latest MLflow run. Returns a dictionary mapping numerical labels to anomaly type names.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def load_anomaly_type_mapping() -&gt; dict[int, str]:\n    \"\"\"\n    Load the anomaly type mapping from the latest MLflow run.\n    Returns a dictionary mapping numerical labels to anomaly type names.\n    \"\"\"\n    try:\n        client = MlflowClient()\n        experiment = client.get_experiment_by_name(\"cubestocker_experiment\")\n        if experiment is None:\n            return {0: \"Normal\"}\n\n        runs = client.search_runs(\n            experiment_ids=[experiment.experiment_id],\n            order_by=[\"metrics.cv_mean_auroc DESC\"],\n            max_results=1,\n        )\n\n        if not runs:\n            return {0: \"Normal\"}\n\n        best_run = runs[0]\n        artifacts = client.list_artifacts(best_run.info.run_id)\n\n        # Look for the anomaly_type_mapping.json artifact\n        mapping_artifact = None\n        for artifact in artifacts:\n            if artifact.path == \"anomaly_type_mapping.json\":\n                mapping_artifact = artifact\n                break\n\n        if mapping_artifact:\n            import json\n\n            mapping_path = client.download_artifacts(best_run.info.run_id, \"anomaly_type_mapping.json\")\n            with open(mapping_path) as f:\n                forward_mapping = json.load(f)  # name -&gt; number\n\n            # Reverse the mapping to get number -&gt; name\n            reverse_mapping = {v: k for k, v in forward_mapping.items()}\n            return reverse_mapping\n        else:\n            return {0: \"Normal\"}\n\n    except Exception as e:\n        print(f\"[WARNING] Could not load anomaly type mapping: {e}\")\n        return {0: \"Normal\"}\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.load_model_from_registry","title":"<code>load_model_from_registry(model_name)</code>","text":"<p>Loads the version of <code>model_name</code> that is currently in the 'Production' stage. Raises RuntimeError if no version is in 'Production' or if loading fails.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>Name of the OCC model</p> required <p>Returns:     The model in the 'Production' stage</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def load_model_from_registry(model_name: str) -&gt; Any:\n    \"\"\"\n    Loads the version of `model_name` that is currently in the 'Production' stage.\n    Raises RuntimeError if no version is in 'Production' or if loading fails.\n\n    Args:\n        model_name: Name of the OCC model\n    Returns:\n        The model in the 'Production' stage\n    \"\"\"\n    client = MlflowClient()\n    versions = client.search_model_versions(f\"name='{model_name}'\")\n    for v in versions:\n        if v.current_stage == \"Production\":\n            model_uri = f\"models:/{model_name}/{v.version}\"\n            try:\n                model = mlflow.sklearn.load_model(model_uri)\n            except Exception as e:\n                raise ModelLoadError(v.version, e) from e\n            return model\n    raise NoProductionModelError(model_name)\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.nested_cross_validate","title":"<code>nested_cross_validate(X, y)</code>","text":"<p>Performs a 5-fold outer cross-validation using XGBoost Classifier model for multi-class anomaly classification.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Feature matrix of shape (n_samples, n_features).</p> required <code>y</code> <code>ndarray</code> <p>Multi-class target array of shape (n_samples,), where 0 indicates normal instances and 1+ indicates different anomaly types.</p> required <p>Returns:</p> Type Description <code>tuple[list[dict], dict]</code> <p>tuple[list[dict], dict] containing a list of dictionaries, each containing results from one fold and a dictionary corresponding to the best fold, selected by highest AUROC.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def nested_cross_validate(X: np.ndarray, y: np.ndarray) -&gt; tuple[list[dict], dict]:\n    \"\"\"\n    Performs a 5-fold outer cross-validation using XGBoost Classifier\n    model for multi-class anomaly classification.\n\n    Args:\n        X (np.ndarray): Feature matrix of shape (n_samples, n_features).\n        y (np.ndarray): Multi-class target array of shape (n_samples,), where 0 indicates normal instances and 1+ indicates different anomaly types.\n\n    Returns:\n        tuple[list[dict], dict] containing a list of dictionaries, each containing results from one fold and a dictionary corresponding to the best fold, selected by highest AUROC.\n    \"\"\"\n    y = np.asarray(y, dtype=int)\n\n    print(\"[INFO] Starting Outer Cross Validation with 5 folds...\")\n    print(f\"[INFO] Dataset: {X.shape[0]} samples, {X.shape[1]} features\")\n    skf_outer = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n    fold_results = []\n\n    total_folds = 5\n    for fold_idx, (train_i, test_i) in enumerate(skf_outer.split(X, y), start=1):\n        print(f\"\\n[INFO] ========== FOLD {fold_idx}/{total_folds} ==========\")\n        X_tr, y_tr = X[train_i], y[train_i]\n        X_te, y_te = X[test_i], y[test_i]\n\n        # XGBoost parameters for multi-class classification\n        xgb_params = {\n            \"objective\": \"multi:softprob\",  # Multi-class classification with probability output\n            \"num_class\": len(np.unique(y_tr)),  # Number of classes\n            \"eval_metric\": \"auc\",  # Multi-class auc\n            \"n_estimators\": 100,\n            \"random_state\": 42,\n            \"verbosity\": 0,  # Reduce verbosity\n        }\n\n        sample_weights = compute_sample_weight(class_weight=\"balanced\", y=y_tr)\n\n        # Create XGBoost classifier\n        xgb_model = XGBClassifier(**xgb_params)\n\n        start_time = time.time()\n        model = xgb_model.fit(X_tr, y_tr, sample_weight=sample_weights)\n        fit_time = time.time() - start_time\n\n        start_time = time.time()\n        y_proba = model.predict_proba(X_te)\n        score_time = time.time() - start_time\n\n        # Calculate AUROC for multi-class\n        try:\n            auroc = roc_auc_score(y_te, y_proba, multi_class=\"ovr\", average=\"macro\")\n        except ValueError as e:\n            print(f\"[WARNING] Could not calculate AUROC for fold {fold_idx}: {e}\")\n            auroc = 0.0\n\n        fold_results.append({\n            \"fold\": fold_idx,\n            \"auroc\": auroc,\n            \"fit_time\": fit_time,\n            \"score_time\": score_time,\n            \"model\": model,\n            \"params\": xgb_params,\n        })\n\n    # choose best fold by (AUROC, then AUPRC)\n    best = max(fold_results, key=lambda r: cast(float, r[\"auroc\"]))\n    return fold_results, best\n</code></pre>"},{"location":"modules/#mlflow_fastapi_docker.train_deploy.train_and_log_model","title":"<code>train_and_log_model(noise_pct, noise_std, noise_type, model_name)</code>","text":"<p>Loads \u201cnormal\u201d Cubestocker data. Injects synthetic noise \u2192 anomalies. Runs a 5-fold cross-validation of XGBoost Classifier and logs per-fold metrics + aggregated metrics to MLflow. Registers the best-trained XGBoost Classifier model inside a pipeline that includes scaler + XGBoost Classifier. Finds that best run across all runs (by cv_mean_auroc), then assigns alias \u201cproduction\u201d to the corresponding model version (new API).</p> <p>Parameters:</p> Name Type Description Default <code>noise_pct</code> <code>float</code> <p>Percentage of rows to add noise to</p> required <code>noise_std</code> <code>float</code> <p>Standard deviation of the noise distribution</p> required <code>noise_type</code> <code>str</code> <p>Type of noise to add (gaussian, laplace, poisson, etc.)</p> required <code>model_name</code> <code>str</code> <p>Name of the model.</p> required <p>Returns:     Run_id of the current training run.</p> Source code in <code>src/mlflow_fastapi_docker/train_deploy.py</code> <pre><code>def train_and_log_model(noise_pct: float, noise_std: float, noise_type: str, model_name: str) -&gt; str:\n    \"\"\"\n    Loads \u201cnormal\u201d Cubestocker data.\n    Injects synthetic noise \u2192 anomalies.\n    Runs a 5-fold cross-validation of XGBoost Classifier and logs per-fold metrics + aggregated metrics to MLflow.\n    Registers the best-trained XGBoost Classifier model inside a pipeline that includes scaler + XGBoost Classifier.\n    Finds that best run across all runs (by cv_mean_auroc), then assigns alias \u201cproduction\u201d to the corresponding model version (new API).\n\n    Args:\n        noise_pct: Percentage of rows to add noise to\n        noise_std: Standard deviation of the noise distribution\n        noise_type: Type of noise to add (gaussian, laplace, poisson, etc.)\n        model_name: Name of the model.\n    Returns:\n        Run_id of the current training run.\n    \"\"\"\n    # 1) Load &amp; add noise\n    filenames = [\n        \"TRACKING_20250502_a_20250508\",\n        \"TRACKING_20250509_a_20250515\",\n        \"TRACKING_20250516_a_20250522\",\n        \"TRACKING_20250523_a_20250529\",\n    ]\n    df, scaler, feature_cols = load_and_preprocess_data(filenames)\n    df = add_noise(df, noise_pct, noise_std, noise_type, feature_cols)\n\n    # 2) Reverse-scale &amp; symbolic labeling\n    reversed_data = scaler.inverse_transform(df[feature_cols])\n    reversed_df = pd.DataFrame(reversed_data, columns=feature_cols)\n    reversed_df[\"Anomaly_Label\"] = df[\"Anomaly_Label\"]\n    reversed_df[\"symbolic_labels\"] = reversed_df.apply(get_anomaly_labels, axis=1)\n\n    # 3) Build anomaly-type \u2192 int mapping\n    all_anomaly_types = set()\n    for labels_list in reversed_df[\"symbolic_labels\"]:\n        for label in labels_list:\n            # Extract only the anomaly type string, excluding the parenthesized part\n            anomaly_type = label.split(\" (\")[0]\n            all_anomaly_types.add(anomaly_type)\n\n    sorted_anomaly_types = sorted(all_anomaly_types)\n    anomaly_type_mapping = {anom_type: i + 1 for i, anom_type in enumerate(sorted_anomaly_types)}\n    anomaly_type_mapping[\"Normal\"] = 0  # Add label for normal data\n\n    # 4) Create numeric labels\n    reversed_df[\"Anomaly_Type_Label\"] = 0  # Initialize with 0 (Normal)\n    reversed_df[\"Anomaly_Type_Label\"] = reversed_df.apply(\n        lambda row: get_numerical_anomaly_label(row, anomaly_type_mapping), axis=1\n    )\n    reversed_df = reversed_df.drop(columns=[\"symbolic_labels\", \"Anomaly_Label\"])\n\n    # 5) Rescale features and split X/y\n    feature_cols_reversed = [c for c in reversed_df.columns if c != \"Anomaly_Type_Label\"]\n    X_before_scaling = reversed_df[feature_cols_reversed]\n    y = reversed_df[\"Anomaly_Type_Label\"]\n\n    X_array = scaler.fit_transform(X_before_scaling)\n    y_array = y.to_numpy()\n\n    # 6) MLflow run\n    with mlflow.start_run() as run:\n        run_id: str = run.info.run_id\n        experiment_id = run.info.experiment_id\n\n        mlflow.log_dict(anomaly_type_mapping, \"anomaly_type_mapping.json\")\n\n        # 7) Cross-validate &amp; log metrics\n        folds, best = nested_cross_validate(X_array, y_array)\n\n        # log noise parameters\n        mlflow.log_param(\"noise_pct\", noise_pct)\n        mlflow.log_param(\"noise_std\", noise_std)\n        mlflow.log_param(\"noise_type\", noise_type)\n        mlflow.log_param(\"model_type\", \"XGBoost\")\n        mlflow.log_param(\"num_classes\", len(np.unique(y_array)))\n\n        # log metrics per fold\n        aurocs, fit_times, score_times = [], [], []\n        for f in folds:\n            mlflow.log_metric(f\"fold{f['fold']}_AUC\", f[\"auroc\"])\n            mlflow.log_metric(f\"fold{f['fold']}_fit_time\", f[\"fit_time\"])\n            mlflow.log_metric(f\"fold{f['fold']}_score_time\", f[\"score_time\"])\n            aurocs.append(f[\"auroc\"])\n            fit_times.append(f[\"fit_time\"])\n            score_times.append(f[\"score_time\"])\n\n        # log aggregated metrics\n        mlflow.log_metric(\"cv_mean_auroc\", np.mean(aurocs))\n        mlflow.log_metric(\"cv_std_auroc\", np.std(aurocs))\n        mlflow.log_metric(\"cv_mean_fit_time\", np.mean(fit_times))\n        mlflow.log_metric(\"cv_mean_score_time\", np.mean(score_times))\n\n        # log best fold\n        mlflow.log_param(\"best_fold\", best[\"fold\"])\n        for k, v in best[\"params\"].items():\n            mlflow.log_param(f\"best_param_{k}\", v)\n\n        # 8) Log &amp; register model\n        frozen_xgb = best[\"model\"]\n        pipeline = Pipeline([\n            (\"scaler\", scaler),\n            (\"model\", frozen_xgb),\n        ])\n        sample_df = df[feature_cols_reversed].iloc[:5]\n        sample_preds = pipeline.predict(sample_df)\n        signature = infer_signature(sample_df, sample_preds)\n\n        mlflow.sklearn.log_model(\n            sk_model=pipeline,\n            artifact_path=\"model\",\n            registered_model_name=model_name,\n            signature=signature,\n            input_example=sample_df.to_dict(orient=\"records\"),\n        )\n        print(f\"Model trained and logged. Run ID: {run_id}\")\n        try:\n            register_best_model(model_name, experiment_id, best)\n        except Exception as e:\n            print(f\"[WARNING] Failed to transition model to 'Production': {e}\")\n\n        return run_id\n</code></pre>"}]}